笔记来源：[尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）](https://www.bilibili.com/video/BV1PJ411n7xZ "尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）")

> 同步更新：https://gitee.com/vectorx/NOTE_JVM
>
> https://codechina.csdn.net/qq_35925558/NOTE_JVM
>
> https://github.com/uxiahnan/NOTE_JVM

[TOC]

# 1.JVM 与 Java 体系结构

## 1.1. 前言

作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？

- 运行着的线上系统突然卡死，系统无法访问，甚至直接**OOM**；
- 想解决线上 JVM GC 问题，但却无从下手；
- 新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了；
- 每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼；

![image-20200704111417472](https://img-blog.csdnimg.cn/img_convert/4f09fe3576573558bdc61985a8ad6a42.png)

大部分 Java 开发人员，除会在项目中使用到与 Java 平台相关的各种高精尖技术，对于 Java 技术的核心 Java 虚拟机了解甚少。

**开发人员如何看待上层框架**

一些有一定工作经验的开发人员，打心眼儿里觉得 SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。

如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。

![image-20200704112119729](https://img-blog.csdnimg.cn/img_convert/b8b64926837d355213a8ce16c119da6b.png)

计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言

**我们为什么要学习 JVM？**

- 面试的需要（BATJ、TMD，PKQ 等面试都爱问）
- 中高级程序员必备技能
  - 项目管理、调优的需求
- 追求极客的精神
  - 比如：垃圾回收算法、JIT、底层原理

**Java vs C++**

![image-20200704112700211](https://img-blog.csdnimg.cn/img_convert/8fd76611be7ea81ebcfe7c4065dd3294.png)

垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。

## 1.2. 面向人群及参考书目

![image-20210507095948516](https://img-blog.csdnimg.cn/img_convert/555790a8a0b57075bdc8b6116545e461.png)

![image-20200704145340513](https://img-blog.csdnimg.cn/img_convert/33c00a1933a8fbdf47db211178125621.png)

![image-20210507100021400](https://img-blog.csdnimg.cn/img_convert/f4cd25ee025347ae9481e26b89331041.png)

![image-20210507100104455](https://img-blog.csdnimg.cn/img_convert/c56a02961383aca01f642eb9a1b81ab1.png)

## 1.3. Java 及 JVM 简介

**TIOBE 语言热度排行榜：[index | TIOBE - The Software Quality Company](https://tiobe.com/tiobe-index/)**

| Programming Language | 2021 | 2016 | 2011 | 2006 | 2001 | 1996 | 1991 | 1986 |
| :------------------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| C                    | 1    | 2    | 2    | 2    | 1    | 1    | 1    | 1    |
| Java                 | 2    | 1    | 1    | 1    | 3    | 26   | -    | -    |
| Python               | 3    | 5    | 6    | 8    | 27   | 19   | -    | -    |
| C++                  | 4    | 3    | 3    | 3    | 2    | 2    | 2    | 8    |
| C#                   | 5    | 4    | 5    | 7    | 13   | -    | -    | -    |
| Visual Basic         | 6    | 13   | -    | -    | -    | -    | -    | -    |
| JavaScript           | 7    | 8    | 10   | 9    | 10   | 32   | -    | -    |
| PHP                  | 8    | 6    | 4    | 4    | 11   | -    | -    | -    |
| SQL                  | 9    | -    | -    | -    | -    | -    | -    | -    |
| R                    | 10   | 17   | 31   | -    | -    | -    | -    | -    |
| Lisp                 | 34   | 27   | 13   | 14   | 17   | 7    | 4    | 2    |
| Ada                  | 36   | 28   | 17   | 16   | 20   | 8    | 5    | 3    |
| (Visual) Basic       | -    | -    | 7    | 6    | 4    | 3    | 3    | 5    |

世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言

**JVM：跨语言的平台**

Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。

- 作为一个平台，Java 虚拟机扮演着举足轻重的作用
  - Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分
- 作为灯种文化，Java 几乎成为了“开源”的代名词。
  - 第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。
  - 就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。
- 作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。

![image-20200704151731216](https://img-blog.csdnimg.cn/img_convert/69fa9f3a1421d7dffc8b193084c8ae04.png)

每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过 Java 虚拟机进行运行和处理

![image-20200704152052489](https://img-blog.csdnimg.cn/img_convert/a9546b59e32abb4cc36b02b2f72bddad.png)

- 随着 Java7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在<mark>Java 虚拟机平台上运行非 Java 语言编写的程序。</mark>
- Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<mark>它只关心“字节码”文件</mark>。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。

**字节码**

- 我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：<mark>jvm 字节码</mark>。
- 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。
- Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

**多语言混合编程**

- <mark>Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</mark>
- 试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<mark>各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。</mark>
- 对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），<mark>推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。</mark>

**如何真正搞懂 JVM？**

Java 虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！

自己动手写一个 Java 虚拟机，难吗？

天下事有难易乎？

为之，则难者亦易矣；不为，则易者亦难矣

![image-20210507102334642](https://img-blog.csdnimg.cn/img_convert/b97b2bf5eafd843f7b149e98ff4d615f.png)

## 1.4. Java 发展的重大事件

- 1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java
- 1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。
- 1996 年 1 月 23 日，Sun Microsystems 发布了 JDK 1.0。
- 1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP/Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。
- 2000 年，JDK1.3 发布，<mark>Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。</mark>
- 2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。
- 2003 年年底，<mark>Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</mark>
- 2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。
- 2006 年，JDK6 发布。同年，<mark>Java 开源并建立了 OpenJDK</mark>。顺理成章，<mark>Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。</mark>
- 2007 年，<mark>Java 平台迎来了新伙伴 Clojure。</mark>
- 2008 年，Oracle 收购了 BEA，<mark>得到了 JRockit 虚拟机。</mark>
- 2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala，这是 Java 平台的又一次大规模应用。
- 2010 年，Oracle 收购了 Sun，<mark>获得 Java 商标和最真价值的 HotSpot 虚拟机</mark>。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit
- 2011 年，JDK7 发布。在 JDK1.7u4 中，<mark>正式启用了新的垃圾回收器 G1。</mark>
- 2017 年，JDK9 发布。<mark>将 G1 设置为默认 Gc，替代 CMS</mark>
- 同年，<mark>IBM 的 J9 开源</mark>，形成了现在的 Open J9 社区
- 2018 年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计 88 亿美元
- 同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会
- 同年，JDK11 发布，LTS 版本的 JDK，<mark>发布革命性的 ZGC，调整 JDK 授权许可</mark>
- 2019 年，JDK12 发布，加入 RedHat 领导开发的<mark>shenandoah GC</mark>

![image-20200704182035810](https://img-blog.csdnimg.cn/img_convert/577ba2f5110b972116602fb2ce3291e8.png)

在 JDK11 之前，OracleJDK 中还会存在一些 OpenJDK 中没有的、闭源的功能。但在 JDK11 中，我们可以认为 OpenJDK 和 OracleJDK 代码实质上已经完全一致的程度。

不过，主流的 JDK 8 在 2019 年 01 月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。

![img](https://img-blog.csdnimg.cn/img_convert/8a37d7f7b848e7453e622270217ce7dc.png)

## 1.5. 虚拟机与 Java 虚拟机

**虚拟机**

所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

- 大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。
- 程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。

无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。

**Java 虚拟机**

- Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。
- JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。
- <mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。

作用

- Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

特点

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能

**JVM 的位置**

![image-20200704183048061](https://img-blog.csdnimg.cn/img_convert/6b5c24b8d634d5a741ef5d8a90db1123.png)

JVM 是运行在操作系统之上的，它与硬件没有直接的交互
![image-20210507104030823](https://img-blog.csdnimg.cn/img_convert/cd8b795cf080b8ba40f6915b6242c8af.png)

## 1.6. JVM 的整体结构

![image-20200704183436495](https://img-blog.csdnimg.cn/img_convert/1bf0b96d082d684a818bc36a8f864a89.png)

- HotSpot VM 是目前市面上高性能虚拟机的代表作之一。
- 它采用解释器与即时编译器并存的架构。
- 在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++程序一较高下的地步。

## 1.7. Java 代码执行流程

![image-20200704210429535](https://img-blog.csdnimg.cn/img_convert/4ce09e21efc2533d2b80f45f97b35a48.png)

## 1.8. JVM 的架构模型

Java 编译器输入的指令流基本上是一种基于<mark>栈的指令集架构</mark>，另外一种指令集架构则是基于<mark>寄存器的指令集架构</mark>。

具体来说：这两种架构之间的区别：

**基于栈式架构的特点**

- 设计和实现更简单，适用于资源受限的系统
- 避开了寄存器的分配难题：使用零地址指令方式分配
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台

**基于寄存器架构的特点**

- 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

**举例 1**

同样执行 2+3 这种逻辑操作，其指令分别如下：

基于栈的计算流程（以 Java 虚拟机为例）：

```java
iconst_2 //常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd //常量2/3出栈，执行相加
istore_0 // 结果5入栈
```

而基于寄存器的计算流程

```java
mov eax,2 //将eax寄存器的值设为1
add eax,3 //使eax寄存器的值加3
```

**举例 2**

```java
public int calc(){
    int a=100;
    int b=200;
    int c=300;
    return (a + b) * c;
}
```

```java
> javap -c Test.class
...
public int calc();
    Code:
    Stack=2,Locals=4,Args_size=1
       0: bipush        100
       2: istore_1
       3: sipush        200
       6: istore_2
       7: sipush        300
      10: istore_3
      11: iload_1
      12: iload_2
      13: iadd
      14: iload_3
      15: imul
      16: ireturn
}
```

**总结**

<mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？

## 1.9. JVM 的生命周期

**虚拟机的启动**

Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

**虚拟机的执行**

- 一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。
- 程序开始执行时他才运行，程序结束时他就停止。
- <mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark>

**虚拟机的退出**

有如下的几种情况：

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统用现错误而导致 Java 虚拟机进程终止
- 某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。
- 除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。

## X. JVM 的发展历程

### Sun Classic VM

- 早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是<mark>世界上第一款商用 Java 虚拟机</mark>，JDK1.4 时完全被淘汰。
- 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。
- 如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。
- 现在 hotspot 内置了此虚拟机。

### Exact VM

- 为了解决上一个虚拟机问题，jdk1.2 时，Sun 提供了此虚拟机。
- Exact Memory Management：准确式内存管理
  - 也可以叫 Non-Conservative/Accurate Memory Management
  - 虚拟机可以知道内存中某个位置的数据具体是什么类型。
- 具备现代高性能虚拟机的维形
  - 热点探测
  - 编译器与解释器混合工作模式
- 只在 solaris 平台短暂使用，其他平台上还是 classic vm
  - 英雄气短，终被 Hotspot 虚拟机替换

### HotSpot VM

- HotSpot 历史
  - 最初由一家名为“Longview Technologies”的小公司设计
  - 1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。
  - JDK1.3 时，HotSpot VM 成为默认虚拟机
- <mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark>
  - 不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot
  - Sun / Oracle JDK 和 OpenJDK 的默认虚拟机
  - 因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）
- 从服务器、桌面到移动端、嵌入式都有应用。
- 名称中的 HotSpot 指的就是它的热点代码探测技术。
  - 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
  - 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

### JRockit

- <mark>专注于服务器端应用</mark>
  - 它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。
- 大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark>
  - 使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。
- 优势：全面的 Java 运行时解决方案组合
  - JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要
  - MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。
- 2008 年，JRockit 被 oracle 收购。
- Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。
- 高斯林：目前就职于谷歌，研究人工智能和水下机器人

### IBM 的 J9

- 全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9
- 市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM
- 广泛用于 IBM 的各种 Java 产品。
- 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。
- 2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9

### KVM 和 CDC / CLDC Hotspot

- Oracle 在 Java ME 产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM
- KVM（Kilobyte）是 CLDC-HI 早期产品
- 目前移动领域地位尴尬，智能机被 Android 和 iOS 二分天下。
- KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
  - 智能控制器、传感器
  - 老人手机、经济欠发达地区的功能手机
- 所有的虚拟机的原则：一次编译，到处运行。

### Azul VM

- 前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEA Liquid VM 是<mark>与特定硬件平台绑定、软硬件配合的专有虚拟机</mark>
  - 高性能 Java 虚拟机中的战斗机。
- Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。
- <mark>每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</mark>
- 2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。

### Liquid VM

- 高性能 Java 虚拟机中的战斗机。
- BEA 公司开发的，直接运行在自家 Hypervisor 系统上
- Liquid VM 即是现在的 JRockit VE（Virtual Edition），<mark>Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</mark>
- 随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。

### Apache Harmony

- Apache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。
- 它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK
- 虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。

### Micorsoft JVM

- 微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。
- 只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。
- 1997 年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 WindowsXP SP3 中抹掉了其 VM。现在 Windows 上安装的 jdk 都是 HotSpot。

### Taobao JVM

- 由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。
- <mark>基于 OpenJDK 开发了自己的定制版本 AlibabaJDK</mark>，简称 AJDK。是整个阿里 Java 体系的基石。
- 基于 OpenJDK Hotspot VM 发布的国内第一个优化、<mark>深度定制且开源的高性能服务器版 Java 虚拟机</mark>。
  - 创新的 GCIH（GC invisible heap）技术实现了 off-heap，<mark>即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</mark>
  - GCIH 中的<mark>对象还能够在多个 Java 虚拟机进程中实现共享</mark>
  - 使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销
  - PMU hardware 的 Java profiling tool 和诊断协助功能
  - 针对大数据场景的 ZenGc
- taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu，损失了兼容性，但提高了性能
  - 目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了。

### Dalvik VM

- 谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。
- Dalvik VM 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件
- 基于寄存器架构，不是 jvm 的栈架构。
- 执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。
  - 它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。
- Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。

### Graal VM

- 2018 年 4 月，oracle Labs 公开了 Graal VM，号称 "Run Programs Faster Anywhere"，野心勃勃。与 1995 年 java 的”write once，run anywhere"遥相呼应。
- Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等
- 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件
- 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。
- 如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。但是 Java 的软件生态没有丝毫变化。

### 总结

具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。

# 2. 类加载子系统

## 2.1. 内存结构概述

- Class 文件

类的编译阶段主要目的是把源码文件编译成 JVM 可以解析的 class 文件，这个阶段会经过词法分析、语法语义分析、生成字节码。

- <mark>类加载子系统</mark>
- 运行时数据区
  - 方法区
  - 堆
  - 程序计数器
  - 虚拟机栈
  - 本地方法栈
- 执行引擎
- 本地方法接口
- 本地方法库

![image-20200705080719531](https://img-blog.csdnimg.cn/img_convert/e4bc9ed374db7f35e68f23f4813205bd.png)

![image-20200705080911284](https://img-blog.csdnimg.cn/img_convert/5f06cd7e27506a91940c7b87e01d0b46.png)

如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？

- 类加载器
- 执行引擎

## 2.2. 类加载器与类的加载过程

**类加载器子系统作用**

![image-20200705081813409](https://img-blog.csdnimg.cn/img_convert/3569bfb903e80b66ee7e972a6b4a5036.png)

- 类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。
- ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。
- 加载的类信息存放于一块称为**方法区**的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）

**类加载器 ClassLoader 角色**

![image-20200705081913538](https://img-blog.csdnimg.cn/img_convert/e8172076eaa7a152408633a353f06b2c.png)

- class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出n个一模一样的实例。
- class file 加载到 JVM 中，被称为DNA元数据模板，放在方法区。
- 在.class 文件->JVM->最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。

**类的加载过程**

```java
/**
 *示例代码
 */
public class HelloLoader {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

用流程图表示上述示例代码：

![image-20200705082255746](https://img-blog.csdnimg.cn/img_convert/8cc54647114c456695ac352336c74600.png)

### 2.2.1 加载阶段

![image-20200705082601441](https://img-blog.csdnimg.cn/img_convert/a9497a1eeb7fae3022846b509186fdcd.png)

- 通过一个类的全限定名获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口；

**补充：加载 class 文件的方式**

- 从<mark>本地系统</mark>中直接加载
- 通过<mark>网络</mark>获取，典型场景：Web Applet
- 从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础
- 运行时计算生成，使用最多的是：<mark>动态代理技术</mark>
- 由其他文件生成，典型场景：<mark>JSP 应用</mark>
- 从专有<mark>数据库</mark>中提取.class 文件，比较少见
- 从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施

### 2.2.2 链接阶段

- **验证（Verify）**：
  - 目的在子确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
  - 主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark>
    1. **文件格式验证**: 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
    2. **元数据验证**：对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Obj-ect`之外。
    3. **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
    4. **符号引用验证**：确保解析动作能正确执行。
- **准备（Prepare）**：
  - 为类变量分配内存并且设置该类变量的默认初始值，即零值；这些变量所使用的内存都将在方法区内进行分配；
  - 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
  - <mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化，我们可以理解为在编译期就将结果放入了常量池；</mark>而只被 **final** 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值；
  - 对于引用数据类型`reference`来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即`null`；
  - <mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。
- **解析（Resolve）**：
  - 将常量池内的<mark>符号引用转换为直接引用</mark>的过程。
  - 事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。这是为了支持Java语言的动态绑定（晚期绑定）。
  - 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
  - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。

### 2.2.3 初始化阶段

对类变量，静态代码块进行初始化操作；

1. 声明类变量指定初始值；
2. 使用静态代码块为类变量指定初始值；

类初始化的步骤：

- 假如这个类还没有被加载和连接，则程序先加载并连接该类；
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类；
- 假如类中有初始化语句，则系统依次执行这些初始化语句。

注：

- <mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark>
- 此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
- 构造器方法中指令按语句在源文件中出现的顺序执行。
- <mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）
- 若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。
- 虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。

```java
public class Text{
    //显示初始化
    //prepare num = 0 -> initialization num = 1
	pubilc static int num = 1;
	
    //静态代码初始化
	static{
		num = 2;
		number = 20;
        System.out.println(num);
        System.out.println(number);//报错，非法前项引用
        //链接的准备过程中为number赋初始值和分配了内存，但是还没有把符号引用转化为直接引用，所以不可以执行。
	}
	
	private static int number = 10;
    //Linking/prepare number = 0 -> initialization number = 20 -> 10 覆盖
    
    public static void main(String[] args){
        System.out.println(num);//2
        System.out.println(number);//10
    }
}
```

字节码文件为

```java
// class version 62.0 (62)
// access flags 0x21
public class Main {

  // compiled from: Main.java

  // access flags 0xA
  private static I num

  // access flags 0xA
  private static I number

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 1 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this LMain; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 9 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    GETSTATIC Main.num : I
    INVOKEVIRTUAL java/io/PrintStream.println (I)V
   L1
    LINENUMBER 10 L1
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    GETSTATIC Main.number : I
    INVOKEVIRTUAL java/io/PrintStream.println (I)V
   L2
    LINENUMBER 11 L2
    RETURN
   L3
    LOCALVARIABLE args [Ljava/lang/String; L0 L3 0
    MAXSTACK = 2
    MAXLOCALS = 1

  // access flags 0x8
  //所有类变量和静态代码块，按照源文件出现的顺序
  //iconst，bipush整型入栈指令
  //iconst -1~5	bipush -128~127
  static <clinit>()V
   L0
    LINENUMBER 2 L0
    ICONST_1
    PUTSTATIC Main.num : I
   L1
    LINENUMBER 4 L1
    ICONST_2
    PUTSTATIC Main.num : I
   L2
    LINENUMBER 5 L2
    BIPUSH 20
    PUTSTATIC Main.number : I
   L3
    LINENUMBER 7 L3
    BIPUSH 10
    PUTSTATIC Main.number : I
    RETURN
    MAXSTACK = 1
    MAXLOCALS = 0
}
```

### 2.2.4 使用

类访问方法区内的数据结构的接口， 对象是Heap区的数据。

### 2.2.5 卸载

Java虚拟机结束生命周期的几种方法：

- 执行了System.exit()方法；
- 程序正常执行结束；
- 程序在执行过程中遇到了异常或错误而异常终止；
- 由于操作系统出现错误而导致Java虚拟机进程终止。

## 2.3. 类加载器分类

JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。

从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。

无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有***3***个，如下所示：

![image-20200705094149223](https://img-blog.csdnimg.cn/img_convert/1e553c6d5254f827d2dfab537bea3ab9.png)

这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。

```java
public class Main {
    public static void main(String[] args) {
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);
        //jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1

        //获取扩展类加载器
        ClassLoader extClassLoaderParent = systemClassLoader.getParent();
        System.out.println(extClassLoaderParent);
        //jdk.internal.loader.ClassLoaders$PlatformClassLoader@16b98e56
        
        //获取引导类加载器
        System.out.println(extClassLoaderParent.getParent());
        //null

        //对于用户自定义类来说，默认使用系统类加载器
        System.out.println(Main.class.getClassLoader());
        //jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1

        //Java的核心类库都是使用引导类加载器进行加载的
        System.out.println(String.class.getClassLoader());
        //null
    }
}
```

### 2.3.1. 虚拟机自带的加载器

**启动类加载器（引导类加载器，Bootstrap ClassLoader）**

- 这个类加载使用***C/C++***语言实现的，嵌套在 JVM 内部。
- 它用来加载 Java 的核心库（$JAVA\_HOME/jre/lib/rt.jar、resources.jar $或$ sun.boot.class.path$路径下的内容），用于提供 JVM 自身需要的类。
- 并不继承自***java.lang.ClassLoader***，没有父加载器。
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
- 出于安全考虑，Bootstrap 启动类加载器只加载包名为 $java、javax、sun$ 等开头的类

**扩展类加载器（Extension ClassLoader）**

- Java 语言编写，由 $sun.misc.Launcher.ExtClassLoader$ 实现。
- 派生于 $ClassLoader$ 类。
- 父类加载器为启动类加载器。
- 从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。

**应用程序类加载器（系统类加载器，AppClassLoader）**

- Java 语言编写，由 $sun.misc.LaunchersAppClassLoader$ 实现。
- 派生于 $ClassLoader$ 类。
- 父类加载器为扩展类加载器。
- 它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库。
- <mark>该类加载是程序中默认的类加载器</mark>，一般来说，Java 应用的类都是由它来完成加载。
- 通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器。

### 2.3.2. 用户自定义类加载器

在 Java 的日常应用程序开发中，类的加载几乎是由上述 $3$ 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？

- 隔离加载类

框架里各自有依赖的 $jar$ 包，如果工程引入这些框架时，有可能出现路径一样，类名相同的情况，这时就会出现类的冲突，这时就需要进行类的仲裁，主流框架都会自定义类的加载器，实现不同的中间类隔离，避免冲突。

- 修改类加载的方式

让类在需要的时候进行类的动态加载。

- 扩展加载源
- 防止源码泄漏

Java代码容易被编译和篡改，可以对字节码文件进行加密，将Java文件加载进入内存中时进行解密，自定义类加载器进行解密操作。

用户自定义类加载器实现步骤：

1. 开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求
2. 在***JDK1.2***之前，在自定义类加载器时，总会去继承***ClassLoader***类并重写 $loadClass()$ 方法，从而实现自定义的类加载类，但是在 $JDK1.2$ 之后已不再建议用户去覆盖 $loadclass()$ 方法，而是建议把自定义的类加载逻辑写在findClass()方法中
3. 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。

```java
//eg
public class CustomClassLoader extends ClassLoader{
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException{
        try{
            //获得class文件的二进制文件，如果指定路径的字节码文件进行了加密，则需要
            //进行解密操作
            byte[] result = getClassFromCustomPath(name);
            if(result == null){
                throw new FileNotFountException();
            }else{
                //与findClass方法搭配使用
                return defineClass(name,result,0,result.length);
            }
        }catch(FileNotFoundException e){
            e.printStackTrace();
        }
        throw new ClassNotFoundException(name);
    }
    
    //从给定路径加载指定类
    //如果指定文件的字节码进行了加密，则需要在此方法中实现解密操作
    private byte[] getClassFromCustomPath(String name){
        return null;
    }
}
```

## 2.4. ClassLoader 的使用说明

ClassLoader 类是一个***抽象类***，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器），Java语言编写。

以下方法都不是抽象方法：

![image-20200705103516138](https://img-blog.csdnimg.cn/img_convert/876534b3c2f447d3fc33e6f1db218068.png)

***sun.misc.Launcher***它是一个 java 虚拟机的入口应用

![image-20200705103636003](https://img-blog.csdnimg.cn/img_convert/a22114b608dffe484041b591d486a7fd.png)

**获取 ClassLoader 的途径**

- 方式一：获取当前 ClassLoader

  ```java
  clazz.getClassLoader()
  ```

- 方式二：获取当前线程上下文的 ClassLoader

  ```java
  Thread.currentThread().getContextClassLoader()
  ```

- 方式三：获取系统的 ClassLoader

  ```java
  ClassLoader.getSystemClassLoader()
  ```

- 方式四：获取调用者的 ClassLoader

  ```java
  DriverManager.getCallerClassLoader()
  ```

## 2.5. 双亲委派机制

$Java$ 虚拟机对 $class$ 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 $class$ 文件加载到内存生成 $class$ 对象。而且加载某个类的 $class$ 文件时，$Java$ 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。

***工作原理***

- 1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
- 2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
- 3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

![image-20200705105151258](https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png)

**举例**

当我们加载***jdbc.jar***用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，接口是由引导类加载器加载的。在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，第三方实现类是由系统类加载器加载，于是进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。

![image-20200705105810107](https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png)

**优势**

- 避免类的重复加载；

一旦父类加载某个类，就不会有子类再次加载。

- 保护程序安全，防止核心 API 被随意篡改
  - 自定义类：java.lang.String
  - 自定义类：java.lang.ShkStart（报错：阻止创建 $java.lang$ 开头的类）

**沙箱安全机制**

[JVM-沙箱安全机制](https://blog.csdn.net/weixin_44976835/article/details/111032933)

自定义 String 类，但是在加载自定义 **String** 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 **Java** 核心源代码的保护，这就是沙箱安全机制。

## 2.6. 其他

### 2.6.1	如何判断两个 class 对象是否相同

在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致，包括包名。
- 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同（自定义String和核心 API String ClassLoader不同）。

换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。

### 2.6.2	对类加载器的引用

JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在***方法区***中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。

### 2.6.3	类的主动使用和被动使用

Java 程序对类的使用方式分为：***主动使用***和***被动使用***。

主动使用，又分为七种情况：

- 创建类的实例

- 访问某个类或接口的静态变量，或者对该静态变量赋值

- 调用类的静态方法

- 反射（比如：Class.forName（"com.atguigu.Test"））

- 初始化一个类的子类

- Java 虚拟机启动时被标明为启动类的类

- JDK 7 开始提供的动态语言支持：

  java.lang.invoke.MethodHandle 实例的解析结果

  REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都**<mark>不会导致类的初始化</mark>**。

# 3. 运行时数据区及程序计数器

## 3.1. 运行时数据区

### 3.1.1. 概述

本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段。

![image-20200705111640511](https://img-blog.csdnimg.cn/img_convert/b5d91ce04cfef9a681bbed216732511a.png)

1. 虚拟机栈

描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个**线帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应这一个**线帧**在虚拟机栈中入栈到出栈的过程。

![](D:\ideal-spoon\JVM\JVM上篇：内存与垃圾回收篇\图片\Java虚拟机栈.png)

2. 本地方法栈

与虚拟机的作用是相似的，只不过虚拟机栈是服务 $Java$ 方法的，而本地方法栈是为虚拟机调用 $Native$ 方法服务的，与虚拟机栈相同的是栈的深度是固定的，当线程申请的大于虚拟机栈的深度就会抛出$StackOverFlowError$ 异常，当然虚拟机栈也可以动态的扩展，如果扩展到无法申请到足够的内存就会抛出$outofMemoryError$ 异常。

3. 方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

4. 堆

是Java虚拟机中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有对象都分配在堆上渐渐变得不那么“绝对”了。

5. 程序计数器

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

Java中最小的执行单位是线程，因为虚拟机的是多线程的，每个线程是抢夺CPU时间片，程序计数器就是存储这些指令去做什么，比如循环，跳转，异常处理等等需要依赖它。

每个线程都有属于自己的程序计数器，而且互不影响，独立存储。



当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们的运行时数据区。

![image-20200705111843003](https://img-blog.csdnimg.cn/img_convert/b3cd82be688254afd263db9094e004a7.png)

运行时数据区处于**内存**中，内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。

红色的为一个进程对应的部分，也可以理解为一个虚拟机实例对应的部分；
灰色的为一个线程对应的部分。

​																												***类加载器子系统***

![image-20210509174724223](https://img-blog.csdnimg.cn/img_convert/d6f0aac226ebab0c435b8fe79995eddc.png)

​							***执行引擎***												***本地方法接口，本地方法库调用***

我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品

![image-20210509174543026](https://img-blog.csdnimg.cn/img_convert/bbf59f2544890b06cdb69b2d7719c060.png)

我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁。

![image-20200705112416101](https://img-blog.csdnimg.cn/img_convert/d9139f792f2d10eb03fb827da25b3b28.png)

​																																					***非堆区***

Java1.8之后使用元数据区实现方法区，方法区在JVM概念中是一个逻辑概念，由虚拟机自己具体实现。

Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与**线程**一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

**灰色**的为单独线程私有的，**红色**的为多个线程共享的。即：

- 每个线程：独立包括程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）。

![image-20200705112601211](https://img-blog.csdnimg.cn/img_convert/0f0cce71a35c12ef13e6482d0663dc21.png)

每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。

![image-20210509173410373](https://img-blog.csdnimg.cn/img_convert/efc4643bdd550c6ecacb9d764e71890e.png)

### 3.1.2. 线程

线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的***本地线程***直接映射。

当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。

操作系统负责所有线程的安排调度到任何一个可用的**CPU**上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。

如果run()出现异常导致Java线程终止，本地线程还要决定JVM是否终止。本地线程会判断当前Java线程是否是最后一个非守护线程
$$
线程
\begin{cases}
守护线程\\
普通线程
\end{cases}
$$
如果是则可以直接退出。

### 3.1.3. JVM 系统线程

如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用`public static void main(String[] args)`的 **main** 线程以及所有这个 main 线程自己创建的线程。

这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：

- <mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。
- <mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。
- <mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持(守护线程)。
- <mark>编译线程</mark>：这种线程在运行时会将字节码编译成到本地代码。
- <mark>信号调度线程</mark>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。

## 3.2. 程序计数器(PC 寄存器)

JVM 中的程序计数寄存器（Program Counter Register）中，Register的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。

![image-20200705155551919](https://img-blog.csdnimg.cn/img_convert/e6785d89d74d694f7cfe22ba74a164d9.png)

​																						***OOM***												***无OOM***

​																							***没有GC(Stack Area/PC Registers)***

### 3.2.1 作用

PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![image-20200705155728557](https://img-blog.csdnimg.cn/img_convert/998d864c026e5d6b565d1cfaecda2bb0.png)

它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。

在 JVM 规范中，<mark>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</mark>。

<mark>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法</mark>。程序计数器会存储当前线程正在执行的 Java 方法的 $JVM$ 指令地址；或者，如果是在执行 $native$ 方法，则是未指定值 $(undefined)$ (PC寄存器是Java层面，本地调用不出来)。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

它是唯一一个在 Java 虚拟机规范中没有规定任何 **OutOfMemoryError** 情况的区域。

### 3.2.2 举例说明

例一：

```java
public class Main {
    public static void main(String[] args) {
        int i = 20;
        int j = 10;
        int k = i + j;
    }
}
```

字节码文件：

```java
{
  public Main();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 6: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
      //指令（偏移）地址：操作指令
      //PC寄存器存储指令地址，执行引擎会根据指令地址读取PC寄存器的指令，
      //然后
      //1.操作局部变量表、操作数栈，2.并翻译成机器指令，以便CPU进行运算
         0: bipush        20//定义为20的值
         2: istore_1		//保存在1的位置
         3: bipush        10//定义为10的值
         5: istore_2
         6: iload_1			//取出
         7: iload_2
         8: iadd			//加和
         9: istore_3
        10: return
      LineNumberTable:
        line 27: 0
        line 28: 3
        line 29: 6
        line 30: 10
}

```

例二：

```java
public int minus(){
    intc = 3;
    intd = 4;
    return c - d;
}
```

字节码文件：

```shell
0: iconst_3
1: istore_1
2: iconst_4
3: istore_2
4: iload_1
5: iload_2
6: isub
7: ireturn
```

**使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？**

因为 $CPU$ 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。

$JVM$ 的字节码解释器就需要通过改变 $PC$ 寄存器的值来明确下一条应该执行什么样的字节码指令。

![image-20200705161409533](https://img-blog.csdnimg.cn/img_convert/68aa12d47725e4559e6b71489d91122e.png)

**PC 寄存器为什么被设定为私有的？**

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换（看似并行实则并发），这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

**CPU 时间片**

CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。

在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。

但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。

![image-20200705161849557](https://img-blog.csdnimg.cn/img_convert/bbab7cdab74c493af70b423f06e6ff86.png)

### 3.2.3 JVM垃圾回收机制

1. **并行**

多条垃圾回收线程并行操作，此时用户线程处于暂停状态（STOP THE WORLD）。

![](D:\ideal-spoon\JVM\JVM上篇：内存与垃圾回收篇\图片\JVM垃圾回收机制并行.png)

2. **并发**

垃圾回收线程和用户线程同时进行（不会出现STOP THE WORLD情况）。

![](D:\ideal-spoon\JVM\JVM上篇：内存与垃圾回收篇\图片\JVM垃圾回收机制并发.png)

3. **串行** 

垃圾回收线程和用户线程交互进行，且垃圾回收线程是**单线程**的。GC在单核和多核CPU环境下都是单线程的。

![](D:\ideal-spoon\JVM\JVM上篇：内存与垃圾回收篇\图片\JVM垃圾回收机制串行.png)

# 4. 虚拟机栈

## 4.1. 虚拟机栈概述

### 4.1.1. 虚拟机栈出现的背景

由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。

<mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。

### 4.1.2. 初步印象

有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？

### 4.1.3. 内存中的栈与堆

<mark>栈是运行时的单位，而堆是存储的单位</mark>

- 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
- 堆解决的是数据存储的问题，即数据怎么放，放哪里。

![image-20200705163928652](https://img-blog.csdnimg.cn/img_convert/2d195f3aafd8b1f426efad75f0a52478.png)

### 4.1.4. 虚拟机栈基本内容

#### Java 虚拟机栈是什么？

Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。**每个**线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的。

#### 生命周期

生命周期和线程一致。

#### 作用

主管 Java 程序的运行，它保存方法的局部变量(八种基本数据类型，对象的引用地址)、部分结果，并参与方法的调用和返回。
$$
变量
\begin{cases}
局部变量\\
成员变量
\end{cases}\\
变量
\begin{cases}
基本数据类型\\
引用数据类型(数组，类，接口等)
\end{cases}
$$


#### 栈的特点

栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。

JVM 直接对 Java 栈的操作只有两个：

- 每个方法执行，伴随着进栈（入栈、压栈）；
- 执行结束后的出栈工作。

对于栈来说不存在垃圾回收问题（栈存在溢出的情况），但是有OOM；

![image-20200705165025382](https://img-blog.csdnimg.cn/img_convert/d4e4445f4faee685dc98d54129344bb3.png)

#### 面试题：开发中遇到哪些异常？

**栈中可能出现的异常**

Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。

- 如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。

  如：递归。

- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。

```java
public static void main(String[] args) {
    test();
}
public static void test() {
    test();
}
//抛出异常：Exception in thread"main"java.lang.StackoverflowError
//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。
```

**设置栈内存大小**

我们可以使用参数**-Xss**选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

```java
public class StackDeepTest{
    private static int count=0;
    public static void recursion(){
        count++;
        recursion();
    }
    public static void main(String args[]){
        try{
            recursion();
        } catch (Throwable e){
            System.out.println("deep of calling="+count);
            e.printstackTrace();
        }
    }
}
```

#### OOM

JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个 $error$ 。

1. 内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用；
2. 内存溢出：申请的内存超过了 $JVM$ 能提供的内存大小。

##### 常见情况

1. 栈内存溢出。栈的大小设置不当引起的。
2. 堆内存溢出。一般由内存泄露和堆的大小设置不当造成的。

## 4.2. 栈的存储单位

### 4.2.1. 栈中存储什么？

每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。

在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。

栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

### 4.2.2. 栈运行原理

JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则</mark>。

在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

![image-20200705203142545](https://img-blog.csdnimg.cn/img_convert/893126a7a33507917e11377fd3e4b639.png)

不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用**return**指令；另外一种是抛出异常，异常会抛出给上一个栈帧，如果被处理，则继续处理指令。不管使用哪种方式，都会导致栈帧被弹出</mark>。

```java
public class CurrentFrameTest{
    public void methodA(){
        system.out.println（"当前栈帧对应的方法->methodA");
        methodB();
        system.out.println（"当前栈帧对应的方法->methodA");
    }
    public void methodB(){
        System.out.println（"当前栈帧对应的方法->methodB");
    }
```

### 4.2.3. 栈帧的内部结构

每个栈帧中存储着：

- <mark>局部变量表（Local Variables）</mark>；
- <mark>操作数栈（operand Stack）（或表达式栈）；</mark>
- 动态链接（DynamicLinking）（或指向运行时常量池的方法引用）；
- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）；
- 一些附加信息。

![image-20200705204836977](https://img-blog.csdnimg.cn/img_convert/0ed2029b435d547547f32540077bb082.png)

并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由<mark>局部变量表</mark>和<mark>操作数</mark>栈决定的。

![image-20200705205443993](https://img-blog.csdnimg.cn/img_convert/2451fa6f061c426179e3674bb6813e46.png)

## 4.3. 局部变量表(Local Variables)

局部变量表也被称之为局部变量数组或本地变量表。

- <mark>定义为一个**数字数组**，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类基本数据类型、对象引用（reference），以及**returnAddress(指向下一条字节码指令的地址)**类型。
- 关于**reference**，它并不等于对象本身，可能是指向对象起始位置地址的指针，也可能指向一个代表对象的句柄和其他与这个对象相关的引用。
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<mark>不存在数据安全问题</mark>。
- <mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的Code属性的maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的（注意这里的大小指的是Slot的数量，Slot的具体大小完全由虚拟机自行解决）。编译器期间也会进行内存分配，一个方法需要的局部变量空间是完全确定的。
- <mark>此处所说的容量大小指的是槽Slot的数量</mark>，具体的内存空间（64位，32位）由具体的虚拟机提供。
- <mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
- <mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

### 4.3.1. 关于 Slot 的理解

- 局部变量表，最基本的存储单元是**Slot**（变量槽）；

- 参数值的存放总是在局部变量数组的**index 0**开始，到数组长度-1的索引结束；

- 局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量；

- 在局部变量表里，32 位以内的类型只占用一个$slot$（包括 $returnAddress$ 类型），64 位的类型（$long$ 和 $double$）占用两个 $slot$ ；

- byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；

- JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值；

- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot上；

- <mark>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</mark>。（比如：访问 long 或 doub1e 类型变量）；

- 如果当前帧是由构造方法或者实例方法创建的，那么<mark>该对象引用 this 将会存放在 index 为 0 的 slot 处</mark>，其余的参数按照参数表顺序继续排列。

  静态方法中不能使用this，局部变量表中不存在this。

![image-20200705212454445](https://img-blog.csdnimg.cn/img_convert/866e014106701648c63c0b232066fced.png)

```java
public class Main {
    public static void main(String[] args) {
        byte i = 15;
        int j = 8;
        int k = i + j;
    }
}

//字节码
0 bipush 15//在byte类型范围内
2 istore_1
3 bipush 8
5 istore_2
6 iload_1
7 iload_2
8 iadd
9 istore_3
10 return
```

改变变量的值

```java
public class Main {
    public static void main(String[] args) {
        byte i = 15;
        int j = 800;
        int k = i + j;
    }
}

//字节码
0 bipush 15
2 istore_1
3 sipush 800//超出byte类型，存入时被认为是short，short再转为int
6 istore_2
7 iload_1
8 iload_2
9 iadd
10 istore_3
11 return
```

### 4.3.2. Slot 的重复利用

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

```java
public class SlotTest {
    public void localVarl() {
        int a = 0;
        System.out.println(a);
        int b = 0;
    }
    public void localVar2() {
        {
            int a = 0;
            System.out.println(a);
        }
        //此时的b就会复用a的槽位
        int b = 0;
    }
}
```

### 4.3.3. 静态变量与局部变量的对比

$$
变量
\begin{cases}
按照数据类型分类
\begin{cases}
基本数据类型\\
引用数据类型
\end{cases}\\
按照在类中的声明位置分类
\begin{cases}
局部变量：使用前必须显式赋值\\
成员变量：都经历过默认赋值
\begin{cases}
类变量(static修饰)：prepare默认赋值，\\\quad\quad\quad initial阶段显示赋值\\
实例变量：随着对象的创建会在堆中分配空间并赋值\\
\end{cases}
\\
\end{cases}
\end{cases}
$$

局部变量的槽位是可以重复利用的，如果局部变量不赋初始数据，则有可能读到脏数据。

参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。

我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。

和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

```java
public void test(){
    int i;
    System.out.println(i);//编译不通过
}
```

这样的代码是错误的，没有赋值不能够使用。

### 4.3.4. 补充说明

在栈帧中，与性能调优关系最为密切的部分就是前面提到的**局部变量表**。在方法执行时，虚拟机使用局部变量表完成方法的传递。

<mark>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。

#### 异常

1. $StackOverflowError$

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 $StackOverflowError$ 异常；

2. $OutOfMemoryError$

如果 $Java$ 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 $OutOfMemoryError$ 异常。

## 4.4. 操作数栈（Operand Stack）

每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的<mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark>

<mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark>

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈；
- 比如：执行复制、交换、求和等操作。

![image-20200706090618332](https://img-blog.csdnimg.cn/img_convert/7f911f276f834d820fa09f31dd63a74b.png)

代码举例

```java
public void testAddOperation(){
    byte i = 15;
    int j = 8;
    int k = i + j;
}
```

字节码指令信息

```shell
public void testAddOperation();
    Code:
    0: bipush 15
    2: istore_1
    3: bipush 8
    5: istore_2
    6:iload_1
    7:iload_2
    8:iadd
    9:istore_3
    10:return
```

操作数栈，<mark>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</mark>。

操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。

每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在**编译期**就定义好了，保存在方法的 $Code$ 属性中，为 $max\_stack$ 的值。

栈中的任何一个元素都是可以任意的 $Java$ 数据类型

- 32bit 的类型占用一个栈单位深度
- 64bit 的类型占用两个栈单位深度

操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问

<mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。

另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。

## 4.5. 代码追踪

```java
public void testAddOperation() {
    byte i = 15;//byte，char，short以int类型存放
    int j = 8;
    int k = i + j;
}
```

使用 javap 命令反编译 class 文件：` javap -v 类名.class`

```java
public void testAddoperation(); 		
Code:	
0: bipush 15 	
2: istore_1 	
3: bipush 8	
5: istore_2	
6: iload_1	
7: iload_2	
8: iadd	
9: istore_3    
10: return
```

非静态方法，位置为零处放置this地址；

![image-20200706093131621](https://img-blog.csdnimg.cn/img_convert/da41b01ad08238a2c8065552aaa7d676.png)

![image-20200706093251302](https://img-blog.csdnimg.cn/img_convert/6867c7a53a4faff29318783b46aef097.png)

![image-20200706093646406](https://img-blog.csdnimg.cn/img_convert/f2d6c5d906914ebdca0a472fee33e047.png)

![image-20200706093751711](https://img-blog.csdnimg.cn/img_convert/6ef9c2eb8ac3395133950caf8ef80da3.png)

![image-20200706093859191](https://img-blog.csdnimg.cn/img_convert/28113c3dc724bbffe677ea61b49e7c56.png)

![image-20200706093921573](https://img-blog.csdnimg.cn/img_convert/f960c074fb4a6b1f35e862568ed23d04.png)

![image-20200706094046782](https://img-blog.csdnimg.cn/img_convert/73a07a0e10bef2537b6da97a5348fee2.png)

![image-20200706094109629](https://img-blog.csdnimg.cn/img_convert/17309b8150015a8b359f2cb2ef78cb60.png)

程序员面试过程中，常见的 i++和++i 的区别，放到字节码篇章时再介绍。

```java
public class Main {
    public static void main(String[] args) {
        //第一类
        int i1 = 10;
        int i2 = i1++;

        int i3 = 10;
        int i4 = ++i3;

        //第二类
        int i5 = 10;
        i5++;

        int i6 = 10;
        ++i6;

        //第三类
        int i7 = 10;
        i7 = i7++;

        int i8 = 10;
        i8 = ++i8;

        //第四类
        int i9 = 10;
        i9 = i9++ + +i9;
    }
}
//字节码文件
 0 bipush 10
 2 istore_1
 3 iload_1
 4 iinc 1 by 1
 7 istore_2
 8 bipush 10
10 istore_3
11 iinc 3 by 1
14 iload_3
15 istore 4
17 bipush 10
19 istore 5
21 iinc 5 by 1
24 bipush 10
26 istore 6
28 iinc 6 by 1
31 bipush 10
33 istore 7
35 iload 7
37 iinc 7 by 1
40 istore 7
42 bipush 10
44 istore 8
46 iinc 8 by 1
49 iload 8
51 istore 8
53 bipush 10
55 istore 9
57 iload 9
59 iinc 9 by 1
62 iload 9
64 iadd
65 istore 9
67 return
```

## 4.6. 栈顶缓存技术（Top Of Stack Cashing）技术

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<mark>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</mark>。

## 4.7. 动态链接（Dynamic Linking）

动态链接、方法返回地址、附加信息 ： 有些地方被称为**帧数据区**；

每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：$invokedynamic$ 指令

在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</mark>。

![image-20200706101251847](https://img-blog.csdnimg.cn/img_convert/31f48e82748240d7694e542374e9d723.png)

为什么需要运行时常量池呢？

常量池的作用：就是为了提供一些符号和常量，便于指令的识别。

## 4.8. 方法的调用：解析与分配

在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

### 4.8.1. 静态链接

当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接。

### 4.8.2. 动态链接

如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。

<mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark>

------

对应的方法的绑定机制为：早期绑定（$Early Binding$）和晚期绑定（$Late Binding$）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark>

### 4.8.3. 早期绑定

早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

$super$ 关键字。

### 4.8.4. 晚期绑定

如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

比如继承类的接口等。

------

随着高级语言的横空出世，类似于 $Java$ 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark>相比于面向过程语言，只具有早期绑定。

$Java$ 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 $C++$ 语言中的虚函数（$C++$ 中则需要使用关键字 $virtual$ 来显式定义）。如果在 $Java$ 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 $final$（不可重写）来标记这个方法。

------

### 4.8.5. 虚方法和非虚方法

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为***非虚方法***。

**静态方法、私有方法、final 方法、实例构造器、父类方法**都是非虚方法。其他方法称为虚方法。

在类加载的解析阶段就可以进行解析，如下是非虚方法举例：

```java
public class Main {
    public static void main(String[] args) {
        Son son = new Son();
        son.show();
    }
}

stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return


class Father {
    public Father() {
        System.out.println("Father的构造器");
    }

    public static void showStatic(String str) {
        System.out.println("Father" + str);
    }

    public final void showFinal() {
        System.out.println("Father show final");
    }

    public void showCommon() {
        System.out.println("Father show common");
    }
}

class Son extends Father {
    public Son() {
        super();
    }

    public Son(int age) {
        this();
    }
//不是重写父类方法，因为静态方法不能被重写
    public static void showStatic(String str) {
        System.out.println("Son" + str);
    }

    private void showPrivate() {
        System.out.println("Son show private");
    }

    public void show() {
        showStatic("1");//子类
        super.showStatic("2");//父类
        showPrivate();
        super.showCommon();
        showFinal();
        //final 方法默认不被重写，指令为invokevirtual
        
        //如果显示调用父类方法
        //super.showFinal()
        //invokespecial
        //但是由于此类被final修饰，我们也认为这是非虚方法
        
        //未显示加上super，则被认为子类重写父类方法，因此为虚方法
        showCommon();
    }
}

//字节码文件Son.class
Code:
      stack=1, locals=1, args_size=1
         0: ldc           #28      // String 1
         2: invokestatic  #30      // Method showStatic:(Ljava/lang/String;)V
         5: ldc           #33      // String 2
         7: invokestatic  #35      // Method Father.showStatic:(Ljava/lang/String;)V
        10: aload_0
        11: invokespecial #36      // Method showPrivate:()V
        14: aload_0
        15: invokespecial #39      // Method Father.showCommon:()V
        18: aload_0
        19: invokevirtual #42      // Method showFinal:()V
        22: aload_0
        23: invokevirtual #45      // Method showCommon:()V

```

虚拟机中提供了以下几条方法调用指令：

#### 普通调用指令：

- <mark>$invokestatic$：调用静态方法，解析阶段确定唯一方法版本</mark>；
- <mark>$invokespecial$：调用需要特殊处理的方法，如实例初始化方法、私有及父类方法，解析阶段确定唯一方法版本</mark>；
- $invokevirtual$：调用所有虚方法；
- $invokeinterface$：调用接口方法；

#### 动态调用指令：

- $invokedynamic$：动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 $invokedynamic$ 指令则支持由用户确定方法版本。<mark>其中 $invokestatic$ 指令和 $invokespecial$ 指令调用的方法称为非虚方法，其余的（$final$ 修饰的除外）称为虚方法。</mark>

**关于 $invokednamic$ 指令**

- JVM 字节码指令集一直比较稳定，一直到 $Java7$ 中才增加了一个 $invokedynamic$ 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark>
- 但是在 Java7 中并没有提供直接生成 $invokedynamic$ 指令的方法，需要借助 ASM 这种底层字节码工具来产生 $invokedynamic$ 指令。<mark>直到 Java8 的 $Lambda$ 表达式的出现，$invokedynamic$ 指令的生成，在 $Java$ 中才有了直接的生成方式。</mark>
- Java7 中增加的动态语言类型支持的本质是对 $Java$ 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。
- 比如使用lambda表达式。

#### 总结

![](D:\BaiduNetdiskDownload\JVM\JVM上篇：内存与垃圾回收篇\图片\方法调用.webp)

#### 动态类型语言和静态类型语言

动态类型语言和静态类型语言两者的区别就在于对***类型的检查***是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。

说的再直白一点就是，<mark>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。

### 4.8.6. 方法重写的本质

**Java 语言中方法重写的本质：**

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。
2. 如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 $java.lang.IllegalAccessError$ 异常。
3. 否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出 $java.lang.AbstractMethodsrror$ 异常。

上面这个过程也被称为动态分配，根据对象的实际类型，来确认调用的方法版本，如果子类有重写方法，就调用子类的方法，否则去父类找对应的方法，这就是 $invokevirtual$ 的指令。

**IllegalAccessError 介绍**

程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。

```java
public class Main {
    public static void main(String[] args) {
        Father son = new Son();
        System.out.println("gay " + son.money);
    }

    static class Father {
        public int money = 1;

        public Father() {
            money = 2;
            show();
        }

        public void show() {
            System.out.println("Father " + money);
        }
    }

    static class Son extends Father {
        public int money = 3;

        public Son() {
            money = 4;
            show();
        }

        @Override
        public void show() {
            System.out.println("Son " + money);
        }
    }
}
```

```java
//输出结果
//Son 0
//Son 4
//gay 2
```

```java
//字节码文件
stack=2, locals=2, args_size=1
    0: new           #7          // class Main$Son
//调用Son的init	1->
    3: dup
    4: invokespecial #9          // Method Main$Son."<init>":()V
    7: astore_1
    8: getstatic     #10         // Field java/lang/System.out:Ljava/io/PrintStream;
    11: aload_1
    12: getfield      #16        // Field Main$Father.money:I
    15: invokedynamic #22,  0    // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;
    20: invokevirtual #26        // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    23: return
```

```java
//1 
Code:
      stack=2, locals=1, args_size=1
         0: aload_0		//加载this进入常量表
         1: invokespecial #1                  // Method Main$Father."<init>":()V
//调用Father的init函数	2->
         4: aload_0
         5: iconst_3	//money赋值3
         6: putfield      #7                  // Field money:I
         9: aload_0
        10: iconst_4
        11: putfield      #7                  // Field money:I
        14: aload_0
        15: invokevirtual #13                 // Method show:()V
//调用Son.show() money为4
        18: return
```

```java
//2
 Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #7                  // Field money:I
         9: aload_0
        10: iconst_2
        11: putfield      #7                  // Field money:I
        14: aload_0
        15: invokevirtual #13                 // Method show:()V
//根据动态分配的原则首先会调用实际类型的重写，也就是调用Son.show()
//而此时Son里的money还没有被赋值，为0(编译过程中默认初始值)
        18: return

```

总结：

访问成员变量的两种方式下的不同规则：

1. **直接访问时，查看父类**：直接通过对象名称访问成员变量：看等号左边是哪个对象（子类或父类），则优先用哪个对象的成员变量，没有则向上找。
2. **成员方法查找当前域**：间接通过成员方法访问成员变量：看该方法属于哪个对象（子类或父类），则优先用哪个对象的方法，没有则向上找。

### 4.8.7. 方法的调用：虚方法表

在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark>

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表是什么时候被创建的呢？

虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。

举例 1：

![image-20200706144954070](https://img-blog.csdnimg.cn/img_convert/79470fa420092e07a411e4e849f743b8.png)

举例 2：

```java
interface Friendly{    
    void sayHello();    
    void sayGoodbye(); 
}

class Dog{    
    public void sayHello(){  
        
    }    
    public String tostring(){  
        return "Dog";    
    }
}

class Cat implements Friendly { 
    public void eat() { 
        
    }    
    public void sayHello() {  
        
    }     
    public void sayGoodbye() { 
        
    }    
    protected void finalize() { 
        
    }
}

class CockerSpaniel extends Dog implements Friendly{    
    public void sayHello() {    
        super.sayHello();    
    }    
    
    public void sayGoodbye() { 
        
    }
}
```

![image-20210509203351535](https://img-blog.csdnimg.cn/img_convert/2264627eaca3c5385a75101478565f5b.png)

## 4.9. 方法返回地址（return address）

存放调用该方法的 $PC$ 寄存器的值。一个方法的结束，有两种方式：

- 正常执行完成；
- 出现未处理的异常，非正常退出。

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 $PC$ 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

当一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令（$return$），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；
   - 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。
   - 在字节码指令中，返回指令包含 $ireturn$（当返回值是 boolean​，byte，char，short 和 int 类型时使用），$lreturn$（Long 类型），$freturn$（Float 类型），$dreturn$（Double 类型），$areturn$。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。
2. 在方法执行过程中遇到异常（$Exception$），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。

方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

```shell
Exception table:from to target type4	 16	  19   any19	 21	  19   any
```

本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。

<mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark>

## 4.10. 一些附加信息

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。

## 4.11. 栈的相关面试题

- 举例栈溢出的情况？（$StackOverflowError$）
  - 通过 -Xss 设置栈的大小
- 调整栈大小，就能保证不出现溢出么？
  - 不能保证不溢出
- 分配的栈内存越大越好么？
  - 不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。
- 垃圾回收是否涉及到虚拟机栈？
  - 不会
- 方法中定义的局部变量是否线程安全？
  - 具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。

| 运行时数据区 | 是否存在 Error | 是否存在 GC |
| :----------- | :------------- | :---------- |
| 程序计数器   | 否             | 否          |
| 虚拟机栈     | 是（SOE）      | 否          |
| 本地方法栈   | 是             | 否          |
| 方法区       | 是（OOM）      | 是          |
| 堆           | 是             | 是          |

# 5. 本地方法接口和本地方法栈

## 5.1. 什么是本地方法？

简单地讲，<mark>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</mark>。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern "c" 告知 c++编译器去调用一个 c 的函数。

> A native method is a Java method whose implementation is provided by non-java code.

在定义一个 native method​ 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。

本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。

![image-20200706164139252](https://img-blog.csdnimg.cn/img_convert/7b36a8321e4c955f06220775c9c2cf4c.png)

举例

```java
public class IHaveNatives{
    public native void methodNative1(int x);
    public native static long methodNative2();
    private native synchronized float methodNative3(Object o);
    native void methodNative4(int[] ary) throws Exception;
}
```

标识符 native 可以与其它 java 标识符连用，但是 abstract 除外

## 5.2. 为什么使用 Native Method？

Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

**与 Java 环境的交互**

<mark>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。</mark>你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。

**与操作系统的交互**

JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<mark>通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。</mark>还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

**Sun's Java**

<mark>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。</mark>jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority()方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() ApI。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVw 调用。

**现状**

<mark>目前该方法使用的越来越少了，除非是与硬件有关的应用</mark>，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。

## 5.2. 本地方法栈

<mark>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</mark>

本地方法栈，也是线程私有的。

允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）

- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。

本地方法是使用 C 语言实现的。

它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。

![image-20200706174708418](https://img-blog.csdnimg.cn/img_convert/b4aea15cec874411f749e336c8b5d8fd.png)

<mark>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</mark>

- 本地方法可以通过本地方法接口来<mark>访问虚拟机内部的运行时数据区</mark>。
- 它甚至可以直接使用本地处理器中的寄存器
- 直接从本地内存的堆中分配任意数量的内存。

<mark>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</mark>如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。

在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。

# 6. 堆

## 6.1. 堆（Heap）的核心概述

堆针对一个 JVM 进程来说是唯一的，也就是一个进程只有一个 JVM，但是进程包含多个线程，他们是共享同一堆空间的。

![image-20200706195127740](https://img-blog.csdnimg.cn/img_convert/0be60cad417bedd46d651f710ae585ce.png)

一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。

Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。

- 堆内存的大小是可以调节的。

《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。

《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（`The heap is the run-time data area from which memory for all class instances and arrays is allocated`）

数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除（方法结束后对象移除，将会频繁GC，影响用户进程）。

堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

![image-20200706201904057](https://img-blog.csdnimg.cn/img_convert/3ae9948d069bd58ccfcda730cc12bf0f.png)

### 6.1.1. 堆内存细分

Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+<mark>永久区</mark>

- **Young Generation Space** 新生区 **Young/New** 又被划分为 **Eden** 区和 **Survivor** 区；
- **Tenure generation space** 养老区 **Old/Tenure**；
- **Permanent Space** 永久区 **Perm**；

Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+<mark>元空间</mark>

- **Young Generation Space**新生区**Young/New**又被划分为**Eden**区和**Survivor**区
- **Tenure generation space**养老区**Old/Tenure**；
- **Meta Space**元空间**Meta**；

约定：新生区（代）<=>年轻代 、 养老区<=>老年区（代）、 永久区<=>永久代

### 6.1.2. 堆空间内部结构（JDK7）

![image-20200706203419496](https://img-blog.csdnimg.cn/img_convert/deafdcce7cf88a496bc231820bb5b007.png)

### 6.1.3. 堆空间内部结构（JDK8）

![image-20200706203835403](https://img-blog.csdnimg.cn/img_convert/ee2836af2e1d5387b4ac58f5eacabbb6.png)

## 6.2. 设置堆内存大小与 OOM

### 6.2.1. 堆空间大小的设置

Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项"-Xmx"和"-Xms"来进行设置（-X是 JVM 的运行参数）。

- "-Xms"用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`；
- "-Xmx"则用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`；

一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会抛出 **OutOfMemoryError** 异常。

通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是<mark>为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</mark>

默认情况下

- 初始内存大小：物理电脑内存大小 / 64；
- 最大内存大小：物理电脑内存大小 / 4；

```java
public class Main {
    public static void main(String[] args) {
        //返回Java虚拟机的初始内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        //返回Java虚拟机试图使用的最大内存总量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms " + initialMemory + " M");
        System.out.println("-Xmx " + maxMemory + " M");

        System.out.println("系统内存大小为： " + initialMemory * 64 / 1024 + " G");
        System.out.println("系统内存大小为： " + maxMemory * 64 / 1024 + " G");
        
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


//-Xms 254 M
//-Xmx 4046 M
//系统内存大小为： 15 G
//系统内存大小为： 252 G
```

查看设置的参数

1. 命令行 $jps$	$jstat -gc$ 进程 $ID$；
2. 配置文件加上 $-XX:+PrintGCDetails$。

![](D:\BaiduNetdiskDownload\JVM\JVM上篇：内存与垃圾回收篇\图片\查看栈的内存分配.png)

总共的堆大小是 （24576+235520）/1024 = 254M；
$$
新生区
\begin{cases}
Survivor区(这两个区域总有一个是空的，即不占空间)
\begin{cases}
S0C\\S1C
\end{cases}
\\
Eden区\\
\end{cases}
$$
计算堆的空间大小的时候，只计算了新生代和老年代区域的大小，没有加上元空间的数据。

### 6.2.2. OutOfMemory 举例

```java
public class OOMTest {
    public static void main(String[]args){
        ArrayList<Picture> list = new ArrayList<>();
        while(true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e){
                e.printStackTrace();
            }
            list.add(new Picture(new Random().nextInt(1024*1024)));
        }
    }
}
```

```java
/*
Exception in thread "main" java.lang.OutofMemoryError: Java heap space
    at com.atguigu. java.Picture.<init>(OOMTest. java:25)
    at com.atguigu.java.O0MTest.main(OOMTest.java:16)
*/
```

## 6.3. 年轻代与老年代

存储在 JVM 中的 Java 对象可以被划分为两类：

- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速；
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。

Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）。

其中年轻代又可以划分为 $Eden$（伊甸园）空间、$Survivor0$ 空间和 $Survivor1$ 空间（有时也叫做 from 区、to 区）。

![image-20200707075847954](https://img-blog.csdnimg.cn/img_convert/f3ee86daaf5076fe22265ffcaa831175.png)

下面这参数开发中一般不会调：

![image-20200707080154039](https://img-blog.csdnimg.cn/img_convert/7d9c2d1f9ef9f315f01b3441c6e81660.png)

配置新生代与老年代在堆结构的占比。

- 默认`-XX:NewRatio=2`，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3；
- 可以修改`-XX:NewRatio=4`，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5；

默认情况下，在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1。但实际中三者比例是6：1：1，这是因为JVM存在一个自适应机制（关闭自适应比例：*-XX:-UseAdaptiveSizePolicy*，加上减号，暂时用不着）。

当然开发人员可以通过选项"-xx:SurvivorRatio"`调整这个空间比例。比如`-xx:SurvivorRatio=8。

<mark>**几乎**所有的Java对象都是在Eden区被new出来的，</mark>如果Eden区放不下就到老年代。绝大部分的 Java 对象的销毁都在新生代进行了。

- IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。

可以使用选项"`-Xmn`"设置新生代最大内存大小，这个参数一般使用默认值就可以了。

![image-20210510105849497](https://img-blog.csdnimg.cn/img_convert/31fd90d99565ec8ce0682a4468076f94.png)

## 6.4. 图解对象分配过程

为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。

1. **new** 的对象先放伊甸园区。此区有大小限制；

2. 当伊甸园的空间填满时（**Survivor** 区满的时候不会触发 **YGC**），程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（ **MinorGC** ），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区；

3. 然后将伊甸园中的剩余对象移动到幸存者 **0** 区；

4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 **0** 区的，如果没有回收，就会放到幸存者 **1** 区；

5. 如果再次经历垃圾回收，此时会重新放回幸存者 **0** 区，接着再去幸存者 **1** 区；

6. 啥时候能去养老区呢？可以设置次数。默认是 **15** 次；

   - <mark>可以设置参数：`-Xx:MaxTenuringThreshold= N`进行设置</mark>；

7. 在养老区，相对悠闲。当养老区内存不足时，再次触发 **GC：Major GC**，进行养老区的内存清理；

8. 若养老区执行了 **Major GC** 之后，发现依然无法进行对象的保存，就会产生 **OOM** 异常。

   ```java
   java.lang.OutofMemoryError: Java heap space
   ```

![第08章_新生代对象分配与回收过程](https://img-blog.csdnimg.cn/img_convert/9d588ca1c3495a21ada5b7fce89c6633.png)

注：只有伊甸园区满的时候会触发 **YGC** ，这时 **JVM** 将会对伊甸园区和 **Survivor** 区（被动进行）同时进行垃圾回收。

**流程图**

![image-20200707091058346](https://img-blog.csdnimg.cn/img_convert/23b91eb543fc0072cb628365267f0089.png)

**总结**

- <mark>针对幸存者 **s0，s1** 区的总结：复制之后有交换，谁空谁是 to</mark>；
- <mark>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代和元空间进行收集</mark>。

**常用调优工具（在 JVM 下篇：性能监控与调优篇会详细介绍）**

- JDK 命令行；
- Eclipse:Memory Analyzer Tool（离线）；
- Jconsole；
- VisualVM；
- Jprofiler；
- Java Flight Recorder；
- GCViewer；
- GC Easy；

## 6.5. Minor GC，MajorGC、Full GC

### 6.5.1 区别

JVM在进行 GC 时，并非每次都对上面三个内存区域（新生代，老年代；方法区）一起回收的，大部分时候回收的都是指<u>新生代</u>。

针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：
  - 新生代收集（Minor GC / Young GC）：只是新生代（Eden/S0，S1）的垃圾收集；
  - 老年代收集（Major GC / Old GC）：只是老年代的圾收集。
    - 目前，只有 CMSGC 会有单独收集老年代的行为；
    - <mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收</mark>
  - 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集；
    - 目前，只有 G1 GC 会有这种行为。
- 整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。

### 6.5.2. 最简单的分代式 GC 策略的触发条件

#### A. 年轻代 GC（Minor GC）触发机制

- 当年轻代空间不足时，就会触发 MinorGC，这里的年轻代满指的是 Eden 区满，Survivor 区满不会引发 GC（每次 Minor GC 会清理年轻代的内存）。
- 因为<mark>Java 对象大多都具备朝生夕灭的特性</mark>，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
- Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

![image-20200707095606813](https://img-blog.csdnimg.cn/img_convert/29146da9c1f3a3241d52201641899020.png)

#### B. 老年代 GC（Major GC / Full GC）触发机制

- 指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了；
- 出现了 Major Gc，经常会伴随至少一次的Minor GC（但非绝对的，在 Paralle1 Scavenge 收集器的收集策略里就有直接进行MajorGC的策略选择过程）；
  - 也就是在老年代空间不足时，会先尝试触发 Minor Gc。如果之后空间还不足，则触发Major GC
- Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长（调优的策略是减少Major GC的次数）；
- 如果 Major GC 后，内存还不足，就报 OOM 了。

#### C. Full GC 触发机制（后面细讲）

触发 Full GC 执行的情况有如下五种：

1. 调用 System.gc()时，系统建议执行 Full GC，但是不必然执行；
2. 老年代空间不足；
3. 方法区空间不足；
4. 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存；
5. 由 Eden 区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

<mark>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</mark>

## 6.6. 堆空间分代思想

为什么要把 Java 堆分代？不分代就不能正常工作了吗？

经研究，不同对象的生命周期不同。**70%-99%**的对象是临时对象。

- 新生代：有 Eden、两块大小相同的 survivor（又称为**from/to**，**s0/s1**）构成，to 总为空。
- 老年代：存放新生代中经历多次 GC 仍然存活的对象。

![image-20200707101511025](https://img-blog.csdnimg.cn/img_convert/d776de4eb3a801b6e271b3f870317aa1.png)

其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

![image-20200707101543871](https://img-blog.csdnimg.cn/img_convert/9b5ad9b0a881973d2955e61f7ebed160.png)

## 6.7. 内存分配策略

如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为**1**。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代。

对象晋升老年代的年龄阀值，可以通过选项`-XX:MaxTenuringThreshold`来设置

针对不同年龄段的对象分配原则如下所示：

- 优先分配到 Eden；
- 大对象直接分配到老年代（需要连续空间），因为分配到老年代时需要Minor GC和Major GC，导致Stop The World，所以尽量避免程序中出现过多的、朝生夕死的大对象；
- 长期存活的对象分配到老年代；
- 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄**大于或等于**该年龄的对象可以直接进入老年代，无须等到`MaxTenuringThreshold`中要求的年龄；
- 空间分配担保： `-XX:HandlePromotionFailure`。
  大量的对象在GC后仍然存活，Survivor区内存较小，则需要老年代区进行空间分配担保，将Survivor区无法容纳的对象放到老年代区，但是前提是老年代有空间容纳对象。

## 6.8. 为对象分配内存：TLAB

### 6.8.1. 为什么有 TLAB（Thread Local Allocation Buffer）？

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据；
- 由于对象实例的创建 JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的；
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

### 6.8.2. 什么是 TLAB？

- 从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为<mark>每个线程分配了一个私有缓存区域</mark>，它包含在 Eden 空间内。
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<mark>快速分配策略</mark>。
- 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

![image-20210510114110526](https://img-blog.csdnimg.cn/img_convert/90162691ef6b0f4dc96be1c1ab02dc8b.png)

### 6.8.3. TLAB 的再说明

- 尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但<mark>JVM 确实是将 TLAB 作为内存分配的首选</mark>
- 在程序中，开发人员可以通过选项“`-XX:UseTLAB`”设置是否开启 TLAB 空间。
- 默认情况下，TLAB 空间的内存非常小，<mark>仅占有整个 Eden 空间的 1%</mark>，当然我们可以通过选项 “`-XX:TLABWasteTargetPercent`” 设置 TLAB 空间所占用 Eden 空间的百分比大小。
- 一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

![image-20200707104253530](https://img-blog.csdnimg.cn/img_convert/011ab4c65cfe41f64208447bf6c9d6d7.png)

## 6.9. 小结：堆空间的参数设置

官网地址：[https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html)

```java
// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下

-XX:+PrintFlagsInitial  //查看所有的参数的默认初始值
-XX:+PrintFlagsFinal  //查看所有的参数的最终值（可能会存在修改，不再是初始值）
-Xms  //初始堆空间内存（默认为物理内存的1/64）
-Xmx  //最大堆空间内存（默认为物理内存的1/4）
-Xmn  //设置新生代的大小。（初始值及最大值）
-XX:NewRatio  //配置新生代与老年代在堆结构的占比，默认为2
-XX:SurvivorRatio  //设置新生代中Eden和S0/S1空间的比例，默认为8
//若Eden区较小，则频繁进行Minor GC，影响用户进程和整体效率；
//若Eden区较大，则GC失去意义；
    
-XX:MaxTenuringThreshold  //设置新生代垃圾的最大年龄
-XX:+PrintGCDetails //输出详细的GC处理日志
//打印gc简要信息：
//①-Xx：+PrintGC 
//② - verbose:gc
-XX:HandlePromotionFalilure：//是否设置空间分配担保
    
//具体查看某个参数的指令
//1. jps	查看当前运行中的进程号
//2. jinfo -flag 参数 进程号
//就可以查出当前进程号的具体参数
```

在发生**Minor GC**之前，虚拟机会<mark>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</mark>。

- 如果大于，则此次**Minor GC**是安全的；
- 如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。
  - 如果**HandlePromotionFailure=true**，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
    - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
    - 如果小于，则改为进行一次Full GC。
  - 如果**HandlePromotionFailure=false**，则改为进行一次Full GC。

在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为<mark>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC</mark>，否则将进行FullGC。

## 6.X. 堆是分配对象的唯一选择么？

在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：

> 随着 JIT 编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</mark>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。

### 6.X.1. 逃逸分析概述

如何将堆上的对象分配到栈，需要使用逃逸分析手段。

这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

**举例 1**

```java
public void my_method() {
    V v = new V();
    // use v
    // ....
    v = null;
}
```

没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧。

```java
public static StringBuffer createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;//发生了逃逸，对象在外部被引用
}
```

上述方法如果想要`StringBuffer sb`不发生逃逸，可以这样写

```java
public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}
```

**举例 2**

```java
public class EscapeAnalysis {

    public EscapeAnalysis obj;

    /**
     * 方法返回EscapeAnalysis对象，发生逃逸
     * @return
     */
    public EscapeAnalysis getInstance() {
        return obj == null ? new EscapeAnalysis() : obj;
    }

    /**
     * 为成员属性赋值，发生逃逸
     */
    public void setObj() {
        this.obj = new EscapeAnalysis();
    }
    //如果当前obj对象被修饰为static，仍会发生逃逸

    /**
     * 对象的作用于仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis() {
        EscapeAnalysis e = new EscapeAnalysis();
    }

    /**
     * 引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis2() {
        EscapeAnalysis e = getInstance();
        //e 可能是obj也可能是new实体，而这个对象本来就在堆中
    }
}
```

如何快速地判断是否发生了逃逸，就看 $new$ 出的对象实体是否可能在方法外部调用。

注：本方法在内部 $new$ 出来的对象在外部使用是逃逸，使用不属于本方法的对象也是逃逸，即只有在本方法内部创造且不为外部使用的对象才为逃逸。

**参数设置**

在 $JDK 6u23$ 版本之后，$HotSpot$ 中默认就已经开启了逃逸分析。

如果使用的是较早的版本，开发人员则可以通过：

- 选项“`-XX:+DoEscapeAnalysis`"显式开启逃逸分析；
- 通过选项“`-XX:+PrintEscapeAnalysis`"查看逃逸分析的筛选结果；

**结论**：<mark>开发中能使用局部变量的，就不要使用在方法外定义。</mark>

### 6.X.2. 逃逸分析：代码优化

使用逃逸分析，编译器可以对代码做如下优化：

一、<mark>栈上分配</mark>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配

二、<mark>同步省略</mark>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

三、<mark>分离对象或标量替换</mark>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。

#### A. 栈上分配

JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。

**常见的栈上分配的场景**

在逃逸分析中，已经说明了。分别是给*成员变量赋值、方法返回值、实例引用传递*。

```java
public class Main {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 100000000; i++) {
            alloc();
        }

        long end = System.currentTimeMillis();
        System.out.println("花费时间为：" + (end - start) + "ms");
        //-XX:-DoEscapeAnalysis	关闭逃逸分析 52ms
        //-XX:+DoEscapeAnalysis	开启逃逸分析 4ms

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    static void alloc() {
        User user = new User();
    }
}
```

栈上分配是使用标量替换来实现的，把对象换成了基本模型，保存在方法区的局部变量表里。

#### B. 同步省略

线程同步的代价是相当高的，同步的后果是降低并发性和性能。

在动态编译同步块的时候，JIT 编译器可以<mark>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<mark>锁消除</mark>。

**举例**

```java
public void f() {
    Object hellis = new Object();
    synchronized(hellis) {
        System.out.println(hellis);
    }
}
```

代码中hellis这个对象加锁，但是```hellis```对象的生命周期只在```f()```方法中，并不会被其他线程所访问到，每个线程访问到的是不同的对象，所以在 JIT 编译阶段就会被优化掉，优化成：

```java
public void f() {
    Object hellis = new Object();
	System.out.println(hellis);
}
```

#### C. 分离对象或标量替换

<mark>标量（scalar）</mark>是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。

相对的，那些还可以分解的数据叫做<mark>聚合量（Aggregate）</mark>，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

**举例**

```java
public static void main(String args[]) {
    alloc();
}
private static void alloc() {
    Point point = new Point(1,2);
    System.out.println("point.x" + point.x + ";point.y" + point.y);
}
class Point {
    private int x;
    private int y;
}
```

以上代码，经过标量替换后，就会变成

```java
private static void alloc() {
    int x = 1;
    int y = 2;
    System.out.println("point.x = " + x + "; point.y=" + y);
}
```

可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。

**标量替换参数设置**

参数`-XX:EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配到栈上。

上述代码在主函数中进行了 1 亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：

```shell
-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations
```

这里设置参数如下：

- 参数`-server`：启动Server模式，因为在Server模式下，才可以启用逃逸分析。
- 参数`-XX:+DoEscapeAnalysis`：启用逃逸分析
- 参数`-Xmx10m`：指定了堆空间最大为 10MB
- 参数`-XX:+PrintGC`：将打印 Gc 日志
- 参数`-XX:+EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配

### 6.X.3. 逃逸分析小结：逃逸分析并不成熟

关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。

其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </mark>

一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。

虽然这项技术并不十分成熟，但是它也<mark>是即时编译器优化技术中一个十分重要的手段</mark>。

注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确<mark>所有的对象实例都是创建在堆上</mark>。

目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。

## 本章小结

年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。

老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 MinorGc。

当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGc 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。

# 7. 方法区

从内存结构上来看：

![image-20210510141044840](https://img-blog.csdnimg.cn/img_convert/b802b35c3936900c290f8ad123e68b9b.png)

从线程共享与否的角度来看：

![image-20210510141131860](https://img-blog.csdnimg.cn/img_convert/f356e103d9f75e3c0086079bba2b28a9.png)

## 7.1. 栈、堆、方法区的交互关系

![image-20200708094747667](https://img-blog.csdnimg.cn/img_convert/b9f11764ee47b28d37f7764dfd9c9f55.png)

## 7.2. 方法区的理解

官方文档：[Chapter 2. The Structure of the Java Virtual Machine (oracle.com)](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)

![image-20210510195446194](https://img-blog.csdnimg.cn/img_convert/ec22e5d6086dd6219195b2d886118d65.png)

### 7.2.1. 方法区在哪里？

《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。

所以，<mark>方法区看作是一块独立于 Java 堆的内存空间</mark>。

![image-20200708095853544](https://img-blog.csdnimg.cn/img_convert/6a7f2350e0f4e0cde0ac246225e2acdd.png)

### 7.2.2. 方法区的基本理解

- 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。
- 方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：`java.lang.OutOfMemoryError: PermGen space` 或者`java.lang.OutOfMemoryError: Metaspace`
  - <mark>加载大量的第三方的 jar 包；Tomcat 部署的工程过多（30~50 个）</mark>；
  - <mark>大量动态的生成反射类</mark>；
- 关闭 JVM 就会释放这个区域的内存。

### 7.2.3. HotSpot 中方法区的演进

在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。

![image-20210510142516373](https://img-blog.csdnimg.cn/img_convert/fb71df89c52f89d3b711e0b648de244c.png)

本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。Hotspot的设计者选择将收集器分代至方法区，使得垃圾回收器可以像管理Java堆内存一样管理方法区。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。

现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过`-XX:MaxPermsize`上限）

![image-20210510142656677](https://img-blog.csdnimg.cn/img_convert/7d0789c206d53bfb4b6004052236197a.png)

而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存（Native Memory）中实现的元空间（Metaspace）来代替。

![image-20200708103055914](https://img-blog.csdnimg.cn/img_convert/1c229dc39ffc79e8e4f3abf765378d3b.png)

元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<mark>元空间不在虚拟机设置的内存中，而是使用本地内存</mark>。

永久代、元空间二者并不只是名字变了，内部结构也调整了。

根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

## 7.3. 设置方法区大小与 OOM

### 7.3.1. 设置方法区内存的大小

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。

**jdk7及以前**

- <mark>通过`-XX:Permsize`来设置永久代初始分配空间。默认值是 20.75M</mark>。
- <mark>通过`-XX:MaxPermsize`来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</mark>
- 当 JVM 加载的类信息容量超过了这个值，会报异常`OutOfMemoryError:PermGen space`。

![image-20200708111756800](https://img-blog.csdnimg.cn/img_convert/79ec6c83a9b6a4a7281c2ef5442f18ce.png)

**JDK8 以后**

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize`指定；
- 默认值依赖于平台。windows 下，`-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制`。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常`OutOfMemoryError:Metaspace`；
- `-XX:MetaspaceSize`：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的`-XX:MetaspaceSize`值为 21MB。这就是初始的高水位线，一旦触及这个水位线，**Full GC**将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC多次调用。为了避免频繁地 GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。

**举例 1：《深入理解 Java 虚拟机》的例子**

![image-20210510143959924](https://img-blog.csdnimg.cn/img_convert/6d1f5d0e7f035df53d16a16451781677.png)

**举例 2**

```java
/**
 * jdk8中：
 * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m
 * jdk6中：
 * -XX:PermSize=10m-XX:MaxPermSize=10m
 */
public class OOMTest extends ClassLoader{
    public static void main(String[] args){
        int j = 0;
        try{
            OOMTest test = new OOMTest();
            for (int i=0;i<10000;i++){
                //创建Classwriter对象，用于生成类的二进制字节码
                ClassWriter classWriter = new ClassWriter(0);
                //指明版本号，public，类名，包名，父类，接口
                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, "Class" + i, nu1l, "java/lang/Object", null);
                //返回byte[]
                byte[] code = classWriter.toByteArray();
                //类的加载
                test.defineClass("Class" + i, code, 0, code.length); //CLass对象
                j++;
            }
        } finally{
            System.out.println(j);
        }
    }
}
```

### 7.3.2. 如何解决这些 OOM

1. 要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。
3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（`-Xmx`与`-Xms`），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

## 7.4. 方法区的内部结构

![image-20200708161728320](https://img-blog.csdnimg.cn/img_convert/8a5fcba10ccb773f185288ac22bde206.png)

### 7.4.1. 方法区（Method Area）存储什么？

《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：

> 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

![image-20200708161856504](https://img-blog.csdnimg.cn/img_convert/fbe3915506e7979c7d591d17c216fbb1.png)

### 7.4.2. 方法区的内部结构

#### 类型信息

对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：

1. 这个类型的完整有效名称（全名=包名.类名）；
2. 这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）；
3. 这个类型的修饰符（public，abstract，final 的某个子集）；
4. 这个类型直接接口的一个有序列表。

#### 域（Field）信息

JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序；

域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）。

#### 方法（Method）信息

JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：

1. 方法名称；
2. 方法的返回类型（或 void）；
3. 方法参数的数量和类型（按顺序）；
4. 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）；
5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）；
6. 异常表（abstract 和 native 方法除外）；
   - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

#### non-final 的类变量

- 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分；
- 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它。

```java
public class MethodAreaTest {
    public static void main(String[] args) {
        Order order = new Order();
        order.hello();
        System.out.println(order.count);
    }
}
class Order {
    public static int count = 1;
    public static void hello() {
        System.out.println("hello!");
    }
}
```

#### 补充说明：全局常量（static final）

被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

### 7.4.3. 运行时常量池 VS 常量池

![image-20200708171151384](https://img-blog.csdnimg.cn/img_convert/7ec9b450764c623c89e7de7e0d3c8d19.png)

- 方法区，内部包含了运行时常量池（将字节码中的常量池加载到方法区以后）；
- 字节码文件，内部包含了常量池；
- 要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区；
- 要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。

官方文档：[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)

![image-20200708172357052](https://img-blog.csdnimg.cn/img_convert/be6d675673b353a266d48df43b0411f4.png)

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。

#### 为什么需要常量池？

一个Java源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。

比如：如下的代码：

```java
public class SimpleClass {
    public void sayHello() {
        System.out.println("hello");
    }
}
```

虽然只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。

![image-20210510145947122](https://img-blog.csdnimg.cn/img_convert/86cc8ce43ce5bcc9b2b167188b839a1b.png)

#### 常量池中有什么?

几种常量池内存储的数据类型包括：

- 数量值
- 字符串值
- 类引用
- 字段引用
- 方法引用

例如下面这段代码：

```java
public class MethodAreaTest2 {
    public static void main(String args[]) {
        Object obj = new Object();
    }
}
```

`Object obj = new Object();`将会被翻译成如下字节码：

```java
0: new #2  // Class java/lang/Object
1: dup
2: invokespecial // Method java/lang/Object "<init>"() V
```

#### 小结

常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

### 7.4.4. 运行时常量池

- 运行时常量池（Runtime Constant Pool）是方法区的一部分。
- <mark>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</mark>
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<mark>索引访问</mark>的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<mark>真实地址</mark>。
- 运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备<mark>动态性</mark>。
- 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。

## 7.5. 方法区使用举例

```java
public class MethodAreaDemo {
    public static void main(String args[]) {
        int x = 500;
        int y = 100;
        int a = x / y;
        int b = 50;
        System.out.println(a+b);
    }
}
```

序号表示程序计数器记录当前指令的地址。

![image-20210510151436251](https://img-blog.csdnimg.cn/img_convert/b5b9e7f8efd1cf8e889650cea5318b61.png)

![image-20210510151504259](https://img-blog.csdnimg.cn/img_convert/84396fa6be6164ffc54868e78c59dde6.png)

![image-20210510151520952](https://img-blog.csdnimg.cn/img_convert/2214af3dfe294eec73899c935589f569.png)

![image-20210510151609566](https://img-blog.csdnimg.cn/img_convert/64b6b95d37e97205b2f23a089addf321.png)

![image-20210510151648231](https://img-blog.csdnimg.cn/img_convert/692908400668791ac383561affed3520.png)

![image-20210510151712355](https://img-blog.csdnimg.cn/img_convert/885b0a628db8e5d96bd270b6c1073bc6.png)

![image-20210510151753579](https://img-blog.csdnimg.cn/img_convert/922d24be85f3ac3bf951e81bc1101e3d.png)

![image-20210510151829404](https://img-blog.csdnimg.cn/img_convert/67615b1384f553cab185a32460e607eb.png)

![image-20210510151918342](https://img-blog.csdnimg.cn/img_convert/4b80397e4e7a553cc7d7f0f9a8b38d1d.png)

![image-20210510151951327](https://img-blog.csdnimg.cn/img_convert/bcc93f31b5dc95f4676dbd49ecc095d7.png)

![image-20200708205708057](https://img-blog.csdnimg.cn/img_convert/dfba814e0c1b198df7175fe93284c3e0.png)

![image-20210510152102989](https://img-blog.csdnimg.cn/img_convert/35be7c27bee2aa8c0930cffbefa07cd8.png)

![image-20210510152138492](https://img-blog.csdnimg.cn/img_convert/5f2935ec0858f5a74f512018e582f19c.png)

![image-20210510195824437](https://img-blog.csdnimg.cn/img_convert/f584ed9e2b6d99499b2a451a63f12449.png)

![image-20210510195911639](https://img-blog.csdnimg.cn/img_convert/b4428f7f351048601296fe211c40185e.png)

![image-20210510152243933](https://img-blog.csdnimg.cn/img_convert/bf50cc494594b4588794984df6448303.png)

## 7.6. 方法区的演进细节

1. 首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一
2. Hotspot 中方法区的变化：

| JDK版本          |                             变化                             |
| :--------------- | :----------------------------------------------------------: |
| **JDK1.6及以前** |         有永久代（permanet），静态变量存储在永久代上         |
| **JDK1.7**       | 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 |
| **JDK1.8**       | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 |

![image-20200708211541300](https://img-blog.csdnimg.cn/img_convert/1a3aa55257c3150d78327542e5ca230e.png)

![image-20200708211609911](https://img-blog.csdnimg.cn/img_convert/e0f65fc4228d9b6573ae1b23d9a1558b.png)

![image-20200708211637952](https://img-blog.csdnimg.cn/img_convert/c3ed969b0d2bad704c22481208e5dd10.png)

### 7.6.1. 为什么永久代要被元空间替代？

官网地址：[JEP 122: Remove the Permanent Generation (java.net)](http://openjdk.java.net/jeps/122)

![image-20210510163843564](https://img-blog.csdnimg.cn/img_convert/36feeb020d5de3a8c31056f27b27efc4.png)

JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代。

随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<mark>与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）</mark>。

由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。

这项改动是很有必要的，原因有：

- 为永久代设置空间大小是很难确定的。

  在某些场景下，如果动态加载类过多，容易产生 Perm 区的OOM。比如某个实际 Web 工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。

  ```java
  "Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space"
  ```

  而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。

- 对永久代进行调优是很困难的。

有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。

方法区的垃圾收集主要回收两部分内容：针对常量池的回收和对类型的卸载。

### 7.6.2. StringTable 为什么要调整位置？

jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。

这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

### 7.6.3. 静态变量存放在那里？

```java
/**
 * 静态引用对应的对象实体始终都存在堆空间
 * jdk7:
 * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails
 * jdk8:
 * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails
 */
public class StaticFieldTest {
    private static byte[] arr = new byte[1024 * 1024 * 100];
    public static void main(String[] args) {
        System.out.println(StaticFieldTest.arr);

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

```java
/** 
* staticobj、instanceobj、Localobj存放在哪里？ 
*/
public class StaticobjTest {    
    static class Test {        
        static ObjectHolder staticobj = new ObjectHolder();        
        ObjectHolder instanceobj = new ObjectHolder();        
        void foo(){            
            ObjectHolder localobj = new ObjectHolder();
            System.out.println("done");  
        }        
    }    
    private static class ObjectHolder{        
        public static void main(String[] args) {            
            Test test = new StaticobjTest.Test();            
            test.foo();        
        }    
    }
}
```

使用 JHSDB 工具进行分析，这里细节略掉

![image-20200708215218078](https://img-blog.csdnimg.cn/img_convert/e8ced63603ee4a62c9eb7d4c48ae94dd.png)

staticobj 随着 Test 的类型信息存放在方法区，instanceobj 随着 Test 的对象实例存放在 Java 堆，localobject 则是存放在 foo()方法栈帧的局部变量表中。

![image-20200708215025527](https://img-blog.csdnimg.cn/img_convert/e7c6b3dd5175466ee891da9e84577418.png)

测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。

接着，找到了一个引用该 staticobj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：

从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点

## 7.7. 方法区的垃圾回收

有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。

一般来说<mark>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</mark>。但是这部分区域的回收<mark>有时又确实是必要的</mark>。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。

<mark>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</mark>

先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

HotSpot 虚拟机对常量池的回收策略是很明确的，<mark>只要常量池中的常量没有被任何地方引用，就可以被回收</mark>。

回收废弃常量与回收 Java 堆中的对象非常类似。

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

- <mark>该类所有的实例都已经被回收</mark>，也就是 Java 堆中不存在该类及其任何派生子类的实例。
- <mark>加载该类的类加载器已经被回收</mark>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。
- <mark>该类对应的 java.lang.Class对象没有在任何地方被引用</mark>，无法在任何地方通过反射访问该类的方法。

Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class` 以及 `-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息

在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。

## 总结

![image-20200708220303243](https://img-blog.csdnimg.cn/img_convert/f73315a70302396e391a532dcf87ce26.png)

## 常见面试题

> <mark>百度</mark>：
>
> 说一下 JVM 内存模型吧，有哪些区？分别干什么的？
>
> <mark>蚂蚁金服</mark>：
>
> Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？
>
> 一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？
>
> 二面：Eden 和 survior 的比例分配
>
> <mark>小米</mark>：
>
> jvm 内存分区，为什么要有新生代和老年代
>
> <mark>字节跳动</mark>：
>
> 二面：Java 的内存分区
>
> 二面：讲讲 vm 运行时数据库区 什么时候对象会进入老年代？
>
> <mark>京东</mark>：
>
> JVM 的内存结构，Eden 和 Survivor 比例。
>
> JVM 内存为什么要分成新生代，老年代，持久代。
>
> 新生代中为什么要分为 Eden 和 survivor。
>
> <mark>天猫</mark>：
>
> 一面：Jvm 内存模型以及分区，需要详细到每个区放什么。
>
> 一面：JVM 的内存模型，Java8 做了什么改
>
> <mark>拼多多</mark>：
>
> JVM 内存分哪几个区，每个区的作用是什么？
>
> <mark>美团</mark>：
>
> java 内存分配 jvm 的永久代中会发生垃圾回收吗？
>
> 一面：jvm 内存分区，为什么要有新生代和老年代？

# 8. 对象实例化及直接内存

## 8.1. 对象实例化

**面试题**

> <mark>美团</mark>：
>
> 对象在 JVM 中是怎么存储的？
>
> 对象头信息里面有哪些东西？
>
> <mark>蚂蚁金服</mark>：
>
> Java 对象头有什么？

![image-20200709095356247](https://img-blog.csdnimg.cn/img_convert/fe7dfd78e13789563d56f9fbd1b79cad.png)

### 8.1.1. 创建对象的方式

$$
创建对象的方式
\begin{cases}
new
\begin{cases}
最常见的一种\\
变形:Xxx的静态方法\\
工厂模式：XxxBuilder/XxxFactory的静态方法
\end{cases}
\\
Class的newInstance方法:反射的方式，只能调用空参的构造器，权限必须是public\\
使用clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现clone()--浅拷贝\\
使用序列化：从文件中、从网络中获取一个对象的二进制流--深拷贝\\
第三方库Objenesis
\end{cases}
$$

### 8.1.2. 创建对象的步骤

举例：

```java
public class Main {
    public static void main(String[] args) {
        Object obj = new Object();
    }
}

/*
字节码

 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class java/lang/Object
         //调用new操作符
         3: dup
         4: invokespecial #1   				// Method java/lang/Object."<init>":()V
         //调用构造器
         7: astore_1
         8: return
      LineNumberTable:
        line 6: 0
        line 7: 8
}
*/
```



前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：
$$
创建对象的步骤
\begin{cases}
1.判断对象对应的类是否加载链接和初始化\\
2.为对象分配内存
\begin{cases}
如果内存规整--指针碰撞\\
如果内存不规整--
\begin{cases}
虚拟机需要维护一个列表\\
空闲列表分配\\
\end{cases}\\
说明
\end{cases}
\\
3.处理并发安全问题
\begin{cases}
采用CAS配上失败重试保证更新的原子性\\
每一个线程预先分配一个TLAB
\end{cases}\\
4.初始化分配到的空间\\
5.设置对象的对象头\\
6.执行init方法进行初始化
\end{cases}
$$

#### 1. 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。

如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为 key 进行查找对应的 .class 文件；

- 如果没有找到文件，则抛出ClassNotFoundException异常；
- 如果找到，则进行类加载，并生成对应的Class对象。

#### 2. 为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小

**如果内存规整**：虚拟机将采用的是<mark>指针碰撞法（Bump The Point）</mark>来为对象分配内存。

- 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。

**如果内存不规整**：虚拟机需要维护一个<mark>空闲列表（Free List）</mark>来为对象分配内存。

- 已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。

选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。所以当使用Serial、ParNew等带有压缩整理的收集器时，系统所采取的方式是指针碰撞；使用CMS等基于清除处理算法时，只能用空闲列表分配内存。

#### 3. 处理并发问题

- 采用 CAS 失败重试、区域加锁保证更新的原子性
- 每个线程预先分配一块 TLAB：通过设置 `-XX:+UseTLAB`参数来设定

#### 4. 初始化分配到的内存

所有属性设置默认值（第一种），保证对象实例字段在不赋值时可以直接使用。
$$
给对象的属性赋值的操作
\begin{cases}
属性的默认初始化(局部变量没有)\quad\color{Apricot}第四步\\
显式初始化\quad代码中初始化
\\
构造器中初始化
\end{cases}
$$


#### 5. 设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。

#### 6. 执行 init 方法进行初始化

在 Java 程序的视角看来，初始化才正式开始。<mark>初始化成员变量，执行实例化代码块，调用类的构造方法</mark>，并把堆内对象的首地址赋值给引用变量。

因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

**给对象属性赋值的操作**

- 属性的默认初始化
- 显式初始化
- 代码块中初始化
- 构造器中初始化

**对象实例化的过程**

1. 加载类元信息
2. 为对象分配内存
3. 处理并发问题
4. 属性的默认初始化（零值初始化）
5. 设置对象头信息
6. 属性的显示初始化、代码块中初始化、构造器中初始化

## 8.2. 对象内存布局

![](D:\BaiduNetdiskDownload\JVM\JVM上篇：内存与垃圾回收篇\图片\对象内存布局.png)

### 8.2.1. 对象头（Header）

对象头包含了两部分，分别是<mark>运行时元数据（Mark Word）</mark>和<mark>类型指针</mark>。如果是数组，还需要记录数组的长度

#### 运行时元数据

未开启压缩指针时，这部分的长度在32位和64位的虚拟机占32和64个比特位。但由于对象运行时数据占用很多，实际上已经超出了32位和64位比特位，所以它被设计为**动态数据结构**，可以根据对象的状态复用自己的空间。

- 哈希值（HashCode）
- GC 分代年龄
- 锁状态标志
- 线程持有的锁
- 偏向线程 ID
- 偏向时间戳

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空（不需要记录信息）                 | 11     | GC标记             |
| 偏向线程ID，偏向时间戳，对象分代年龄 | 01     | 可偏向             |

#### 类型指针

指向类元数据 InstanceKlass，确定该对象所属的类型。并不是所有的虚拟机都会在对象数据上保留类型指针。

### 8.2.2. 实例数据（Instance Data）

它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）

- 相同宽度的字段总是被分配在一起；
- 父类中定义的变量会出现在子类之前；
- 如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙。

### 8.2.3. 对齐填充（Padding）

不是必须的，也没有特别的含义，仅仅起到占位符的作用。Hotspots虚拟机要求对象起始地址必须是**8**字节的整数倍。

**举例**

```java
public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }

    public Customer() {
        acct = new Account();
    }
}

public class CustomerTest{
    public static void main(string[] args){
        Customer cust=new Customer();
    }
}
```

**图示**

![image-20200709152801713](https://img-blog.csdnimg.cn/img_convert/1bba0ee2a8a614b80d6cac9fecbb3f8a.png)

### 小结

![image-20210510225407119](https://img-blog.csdnimg.cn/img_convert/3be25c48b29d3cef51354f19cbe31d7d.png)

## 8.3. 对象的访问定位

![image-20210510230045654](https://img-blog.csdnimg.cn/img_convert/375b00ca9022291e7d2e214ce2d7cbfd.png)

JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？

![image-20200709164149920](https://img-blog.csdnimg.cn/img_convert/deab7773248ea150e5f7dee3901700cd.png)

### 8.3.1. 句柄访问

堆空间开辟了一块区域叫做**句柄池**，专门存放句柄。

![image-20210510230241991](https://img-blog.csdnimg.cn/img_convert/59cc079fe02b7a5836ff7c2c7fffb635.png)

reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。

效率较低。

### 8.3.2. 直接指针（HotSpot 采用）

![image-20210510230337956](https://img-blog.csdnimg.cn/img_convert/694601dcb023c6d10168a00fe000becc.png)

直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。

## 8.4. 直接内存（Direct Memory）

### 8.4.1. 直接内存概述

不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。<mark>直接内存是在 Java 堆外的、直接向系统申请的内存区间</mark>。来源于 NIO，通过存在堆中的DirectByteBuffer操作 Native 内存。通常，访问直接内存的速度会优于 Java 堆，即<mark>读写性能高</mark>。

- 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存；
- Java 的NIO库允许 Java 程序使用直接内存，用于数据缓冲区。

| IO              | NIO(New IO/Non-Blocking IO 非阻塞式) |
| --------------- | ------------------------------------ |
| byte[] / char[] | Buffer                               |
| Stream          | Channel                              |

举例

```java
public class Main {
    private static int Buffer = 1024 * 1024 * 1024;

    public static void main(String[] args) {
        //GameGUI gameGUI = new GameGUI("pixel");
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(Buffer);

        System.out.println("分配直接内存");
        Scanner scanner = new Scanner(System.in);
        scanner.next();

        byteBuffer = null;
        System.gc();
        scanner.next();
    }
}
//可以在任务管理器看到该程序占用的内存
```

### 8.4.2. 非直接缓存区

使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。

![image-20210510231408607](https://img-blog.csdnimg.cn/img_convert/c691d62d73e977fb942748a81313f5e6.png)

### 8.4.3. 直接缓存区

使用 NIO 时，操作系统划出的直接缓存区可以被 java 代码直接访问，只有一份。NIO 适合对大文件的读写操作。

![image-20210510231456550](https://img-blog.csdnimg.cn/img_convert/d13b08447999ab32811a440496e4dac7.png)

也可能导致 OutOfMemoryError 异常

```java
Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
    at java.nio.Bits.reserveMemory(Bits.java:693)
    at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:123)
    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
    at com.atguigu.java.BufferTest2.main(BufferTest2.java:20)
```

由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。

- 分配回收成本较高
- 不受 JVM 内存回收管理

直接内存大小可以通过`MaxDirectMemorySize`设置。如果不指定，默认与堆的最大值-Xmx 参数值一致

![image-20200709230647277](https://img-blog.csdnimg.cn/img_convert/0ac6c50a98325c93b5652602137b9dea.png)